{"version":3,"sources":["angular-numeric-input.min.js"],"names":["angular","module","directive","$filter","restrict","require","link","scope","el","attrs","ngModelCtrl","round","value","num","parseFloat","d","Math","pow","precision","formatPrecision","toFixed","getCommaCount","length","matchResult","match","formatViewValue","$isEmpty","formatToNumber","numberLength","minValidator","invalid","minNotEqual","min","$setValidity","maxValidator","maxNotEqual","max","lastValidValue","dotSuffix","NUMBER_REGEXP","positiveInteger","maxLength","allowDecimal","$parsers","push","input","isUndefined","replace","lastChar","substr","indexOf","empty","test","$setViewValue","$render","$formatters","$observe","$modelValue","isDefined","val","viewValue","start","selectionStart","end","selectionEnd","oldViewValue","$viewValue","setSelectionRange"],"mappings":"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","file":"angular-numeric-input.min.js","sourcesContent":["(function() {\n    'use strict';\n\n    angular.module('ui.numericInput', [])\n        .directive('uiNumericInput', ['$filter', function($filter) {\n            return {\n                restrict: 'A',\n                require: 'ngModel',\n                link: function(scope, el, attrs, ngModelCtrl) {\n                    var NUMBER_REGEXP = /^\\s*[-+]?(\\d+|\\d*\\.\\d*)\\s*$/,\n                        min = 1,\n                        max,\n                        lastValidValue,\n                        dotSuffix,\n                        positiveInteger = true,\n                        minNotEqual,\n                        maxNotEqual,\n                        maxLength = 9,\n                        precision = 0;\n\n                    if (attrs.maxLength >= 1) {\n                        maxLength = attrs.maxLength;\n                    }\n\n                    if (attrs.allowDecimal) {\n                        positiveInteger = false;\n                        precision = 2;\n                        min = 0;\n                    }\n\n                    if (attrs.minNotEqual) {\n                        minNotEqual = true;\n                    }\n\n                    if (attrs.maxNotEqual) {\n                        maxNotEqual = true;\n                    }\n\n                    /**\n                     * Returns a rounded number in the precision setup by the directive\n                     * @param  {Number} num Number to be rounded\n                     * @return {Number}     Rounded number\n                     */\n                    function round(value) {\n                        var num = parseFloat(value);\n                        var d = Math.pow(10, precision);\n                        return Math.round(num * d) / d;\n                    }\n\n                    /**\n                     * Returns a string that represents the rounded number\n                     * @param  {Number} value Number to be rounded\n                     * @return {String}       The string representation\n                     */\n                    function formatPrecision(value) {\n                        return parseFloat(value).toFixed(precision);\n                    }\n\n                    function getCommaCount(value) {\n                        var length = 0;\n                        var matchResult = (value + '').match(/,/g);\n                        if (matchResult) {\n                            length = matchResult.length;\n                        }\n                        return length;\n                    }\n\n                    //Convert to String\n                    function formatViewValue(value) {\n                        return ngModelCtrl.$isEmpty(value) ? '' : '' + value;\n                    }\n\n                    function formatToNumber(value) {\n                        return $filter('number')(value);\n                    }\n\n                    function numberLength(value) {\n                        var length = 0;\n                        var matchResult = (value + '').match(/\\d/g);\n                        if (matchResult) {\n                            length = matchResult.length;\n                        }\n                        return length;\n                    }\n\n                    function minValidator(value) {\n                        var invalid = minNotEqual ? value <= min : value < min;\n                        if (!ngModelCtrl.$isEmpty(value) && invalid) {\n                            ngModelCtrl.$setValidity('min', false);\n                        } else {\n                            ngModelCtrl.$setValidity('min', true);\n                        }\n                        return value;\n                    }\n\n                    function maxValidator(value) {\n                        var invalid = maxNotEqual ? value >= max : value > max;\n                        if (!ngModelCtrl.$isEmpty(value) && invalid) {\n                            ngModelCtrl.$setValidity('max', false);\n                        } else {\n                            ngModelCtrl.$setValidity('max', true);\n\n                        }\n                        return value;\n                    }\n\n                    ngModelCtrl.$parsers.push(function(input) {\n                        //check undefined and NaN\n                        //http://adripofjavascript.com/blog/drips/the-problem-with-testing-for-nan-in-javascript.html\n                        if (angular.isUndefined(input) || (input !== input)) {\n                            input = '';\n                        }\n\n                        var value = input.replace(/\\,/g, '');\n                        var lastChar = value.substr(value.length - 1);\n                        if (!positiveInteger) {\n                            dotSuffix = lastChar === '.' ? true : false;\n                        }\n\n                        // Handle leading decimal point, like \".5\"\n                        if (value.indexOf('.') === 0) {\n                            value = '0' + value;\n                        }\n\n                        var empty = ngModelCtrl.$isEmpty(value);\n                        if (empty || (NUMBER_REGEXP.test(value) && numberLength(value) <= maxLength)) {\n                            lastValidValue = (value === '') ? null : (empty ? value : round(value));\n                        } else {\n                            // Render the last valid input in the field\n                            ngModelCtrl.$setViewValue(formatViewValue(lastValidValue));\n                            ngModelCtrl.$render();\n                        }\n                        ngModelCtrl.$setValidity('numeric', !dotSuffix);\n                        return lastValidValue;\n                    });\n\n                    ngModelCtrl.$formatters.push(formatToNumber);\n\n                    // Min validation (optional)\n                    attrs.$observe('min', function(value) {\n                        min = parseFloat(value || min);\n                        minValidator(ngModelCtrl.$modelValue);\n                    });\n\n                    ngModelCtrl.$parsers.push(minValidator);\n                    ngModelCtrl.$formatters.push(minValidator);\n\n                    // Max validation (optional)\n                    if (angular.isDefined(attrs.max)) {\n                        attrs.$observe('max', function(val) {\n                            max = parseFloat(val);\n                            maxValidator(ngModelCtrl.$modelValue);\n                        });\n                        ngModelCtrl.$parsers.push(maxValidator);\n                        ngModelCtrl.$formatters.push(maxValidator);\n                    }\n\n                    ngModelCtrl.$formatters.push(function(value) {\n                        return value ? formatPrecision(value) : value;\n                    });\n\n                    //Formatting must be the last of $parser pipeline\n                    ngModelCtrl.$parsers.push(function(value) {\n                        //This section is for decimal values if positiveInteger flag is false\n                        var viewValue = formatToNumber(value);\n                        if (!positiveInteger && dotSuffix) {\n                            viewValue += '.';\n                        }\n                        //This logic is used to preserve cursor position after formatting\n                        var start = el[0].selectionStart,\n                            end = el[0].selectionEnd,\n                            oldViewValue = ngModelCtrl.$viewValue;\n                        if (getCommaCount(oldViewValue) > getCommaCount(viewValue)) {\n                            start--;\n                            end--;\n                        }\n                        if (getCommaCount(oldViewValue) < getCommaCount(viewValue)) {\n                            start++;\n                            end++;\n                        }\n                        //Do not use $setViewValue to set viewValue here, because it will trigger $parse pipeline.\n                        ngModelCtrl.$viewValue = viewValue;\n                        ngModelCtrl.$render();\n                        el[0].setSelectionRange(start, end);\n                        return value;\n                    });\n                }\n            };\n        }]);\n})();"]}